<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="Description" content="SLK is the only true LL(k) parser
 generator. It supports C, C++, C#, Java, and JavaScript with emphasis on simplicity,
 portability, compactness and speed.">
<meta name="KeyWords" content="LL(k) parser generator, parsing, C#,
 Java, C++, C, fast, efficient, slk, JavaScript parser source code,
 C C++ C# Java JavaScript parser generator, parser consultant, parsing consultant,
 custom parsers, custom translators, parser source code">
<meta name="verify-v1" content="RBD0ag71dgyMOW5KM/mF9SWtx4XzD2Ke7Ww2mrh45Ps=" />
<title>The SLK Parser Generator
supports C, C++, Java, JavaScript, and C#, optional backtracking, free
</title>
</head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-139629098-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-139629098-1');
</script>

<body>

<TABLE WIDTH="100%" CELLSPACING=0 CELLPADDING=0 BORDER=0>
<TR>
<TD ALIGN="LEFT" VALIGN="top" NOWRAP>
<IMG SRC="slkimage.png" ALT="SLK">
</TD>
<TD ALIGN="RIGHT" VALIGN="middle" NOWRAP>
<FONT FACE="Verdana, Arial, Helvetica" SIZE=1>
<B>
<a href="index.html">Home</a>
&nbsp;&nbsp;
<a href="documentation.html#SLK_FAQ">FAQ</a>
&nbsp;&nbsp; 
<a href="documentation.html">Docs<a>
&nbsp;&nbsp;
<a href="download.html">Download</a>
&nbsp;&nbsp;
<a href="mailto: SLK Support<mail@h8dems.com>">Support</a>
&nbsp;&nbsp; 
<a href="mailto: SLK Inquiry<mail@h8dems.com>">Contact</a>
</B>
</FONT>
</TD>
</TR>
</TABLE>
<br>

<TABLE cellSpacing=0 cellPadding=5 width="100%" align=center border=0>
<TBODY>
<!-- 
<FONT FACE="Verdana, Arial, Helvetica" SIZE=5>
<B>
SLK Parser Generator
</B>
</FONT>
<TR bgColor=#c3d9ff VALIGN="bottom">
-->
<TR bgColor=#ccddee VALIGN="bottom">
<TD VALIGN="middle">
<FONT FACE="Verdana, Arial, Helvetica" SIZE=5> 
<B>
The SLK Parser Generator
</B>
</FONT>
</TD>
</TR>
</TABLE>

<!-- <FONT FACE="Verdana, Arial, Helvetica"> -->
<B> 
<p>
SLK is the only both LL(k) and LR(k) parser generator available.
The same syntax is used in both, so it is easy to switch
between top-down and bottom-up parsing based on need or
just preference. 
SLK quickly does a full analysis of the
grammar. The SLK algorithm is the only known
solution to this NP-hard problem.
SLK can produce a customizable persistent parse tree
in addition to executing actions during parsing. 
</p>

<!-- 
<FONT FACE="Verdana, Arial, Helvetica" SIZE=5>
<CENTER> <p>
******** This site has moved to <a href="http://www.h8dems.com">http://www.h8dems.com</a> *******
</p> </CENTER>
</FONT>
-->

</B>

<TABLE cellSpacing=7 cellPadding=0 width="90%" align=center border=0>
<TBODY>

<TR bgColor=#dddddd><TD>
SLK implements new lookahead algorithms that are not available
in any other parser generator.
</TD></TR>

<TR bgColor=#ffffff><TD>
SLK produces parsers that are nearly the fastest
and most compact that is possible.
</TD></TR>

<TR bgColor=#dddddd><TD>
The SLK parser generator produces fully modular parsers.
</TD></TR>
                               
<TR bgColor=#ffffff><TD>
SLK currently supports the C, C++, C#, Java, and JavaScript languages.
</TD></TR>

<TR bgColor=#dddddd><TD>
The SLK parser specification language, the grammar, is
completely programming language independent. 
</TD></TR>
                               
<TR bgColor=#ffffff><TD>
SLK introduced a new and more
precise action placement syntax for EBNF notation.
</TD></TR>

<TR bgColor=#dddddd><TD>
SLK supports a new
white space delimited syntax that accepts grammars
in the forms commonly found in published reference grammars.
</TD></TR>

<TR bgColor=#ffffff><TD>
SLK parsers have no library dependencies, so they are well-suited
to embedded applications.
</TD></TR>

<TR bgColor=#dddddd><TD>
SLK includes automated grammar transformation options that
convert reference grammars to top-down format.
</TD></TR>

<TR bgColor=#ffffff><TD>
Predictive backtracking can be enabled under programmer
control as part of the syntax of the SLK parser generator.
</TD></TR>

<TR bgColor=#dddddd><TD>
The SLK parsers are reentrant and thread-safe.
</TD></TR>

<TR bgColor=#ffffff><TD>
Any number of SLK parsers for different grammars can be
contained in a single program.
</TD></TR>

<TR bgColor=#dddddd><TD>
Compiling SLK parsers is never a problem.
All C, C++, C#, Java and JavaScript compilers and interpreters are fully supported.
</TD></TR>

<TR bgColor=#ffffff><TD>
SLK can produce a persistent parse tree to aid in source to source
translation. The parse tree can also be transformed into an AST. 
The parse tree source code is included for customization to produce
whatever shape tree is desired. 
</TD></TR>

<TR bgColor=#dddddd><TD>
The conflict resolution table is exposed as a method call.
This enables adding k lookahead to any other LL or LR parser.
</TD></TR>

<TR bgColor=#ffffff><TD>
SLK can now also generate LR(k) bottom-up parsers, in addition to top-down LL(k).
</TD></TR>

</TABLE>

<B> 
<p>
The SLK Parser Generator produces compact and efficient LR(k) or
LL(k) parsers in C, C++, C#, JavaScript and Java. Features include automated
grammar transformations, clean EBNF syntax, optional backtracking, new
lookahead algorithms, and an uncomplicated API. Under development for over 
25 years, the SLK parser generator is fully supported and is actively
being enhanced on a full time basis. Users are encouraged to
<a href="mailto: SLK Inquiry<mail@h8dems.com>">submit any suggestions</a>
that they have about how SLK can be improved.
</p>
</B>

<B>
<a href="download.html">Download SLK Version 5.12</a>
</B>
<li>
now supports javascript output in addition to C, C++, C#, and java
</li>
<li>
<a href="cgramll.txt">LL(2) C grammar and output.</a>
Handles the typedef problem in actions and error handler. Very compact.
</li>
<li>
<a href="cgram.txt">LALR(3) C grammar and output</a> showing that extra
lookahead can help with the typedef problem and embedded actions.
</li>
<li>
<a href="cppgram.txt">LL(8) C++ grammar and output.</a> Extension
of the base C grammar to support simple C++.
</li>
<li>
<a href="jgramll.txt">LL(5) java grammar and output.</a>
Handles types in actions and error handler. Very compact.
</li>
<li>
<a href="csource.txt">Source code for the C recognizer.</a>
Handles the typedef problem in actions and error handler. 
Full code on the <a href="download.html">download page.</a>
</li>
<li>
<a href="pp.txt">Source code for a C preprocessor.</a>
Illustrates parser reentracy, parsing from not the start symbol, other tricks.
Full code on the <a href="download.html">download page.</a>
</li>
<!-- 
<br>
<B>
<a href="mailto: SLK Consulting<mail@h8dems.com>">Consulting services are available</a>
</B>
<br>
<p> <CENTER>
<B>
******************************************
<br>
<a href="mailto: SLK Purchase Inquiry<mail@h8dems.com>">The SLK lookahead algorithm is for sale</a>
<br>
<a href="mailto: SLK Purchase Bids<mail@h8dems.com>">Submit institutional bids here </a>
<br>
******************************************
</B>
</p> </CENTER>
-->

<h3>
<hr>
More Detail About SLK
</h3>

<p>
An obvious question is "why yet another parser generator?"
The SLK parser generator
is different from all others in two fundamental ways.  
First, it produces table-driven LL(k) parsers instead of
recursive-descent parsers. The table-driven parsers are
generally less than one tenth the size of the equivalent
recursive-descent parsers.  
The SLK tables are actual two dimensional tables rather
than the inefficient linked lists that would be used to implement
a traditional LL(k) parse table. The SLK lookup is fast and
consistent. Exactly "k" lookups are required for an LL(k)
nonterminal. Most grammars contain very few nonterminals
that are not LL(1), so usually only one lookup is required.

<p>
The second difference is that
SLK does a full LL(k) analysis of the
grammar. The SLK algorithm is the only known
solution to this <B>NP-hard problem</B>.
Other deterministic algorithms must either limit k to a very
small value, usually two, or use 
approximate lookahead methods that are considerably weaker
than the LL(k) method.

<p>
The SLK parser generator
also includes the ability to do selective, controlled
nondeterministic parsing where needed.
SLK produces compact and efficient parsing code modules
that can be easily integrated with other generated or hand-written
code modules.  
SLK is targeted to the developer who wants
an uncomplicated tool that is easy to use and easy to learn to use.
                                                                  
<p>
SLK is the only tool available that
enables <B>table-driven LL(k) parsing</B>. Top-down parsing (LL) is
<a href="documentation.html#SLK_Quotations">
thought to be better suited</a>
to syntax directed translation (compilers) than
the bottom-up parsing technique (LALR) that is used by most
parser generators.
The SLK table-driven parsing method is also superior to the recursive-descent
technique that is used by programmers
because it automates much of the process. The simple driver
treats all symbol types of the grammar the same because the
grammar is encoded in a set of tables. In recursive-descent,
all of the productions are individually written out in
the source code of the program. This is tedious, prone to
error, difficult to maintain, and it obscures the grammar
in a way that makes it difficult to determine exactly what
language is really being recognized by the compiler. 
                                                                   
<p>
SLK combines the simplicity and efficiency of the LL(1) method
with the power and flexibility of LL(k)
parsing. The SLK parser generator creates parsers that are
<a href="documentation.html#SLK_Quotations">
smaller and faster</a>
than others.
They also have consistent, easily customizable, automated 
                                                          
<a href="documentation.html#error_recovery">error recovery</a>.

Correctness is easier to demonstrate since the parsing code is
separate from the semantic action code. This improved modularity
also simplifies debugging by fully separating the debugging
of the grammar from that of the semantic action code. Parse
derivation files enable the static examination of the behavior of
the grammar without having to step through the code using a
symbolic debugger. In effect, the parse trace is a flat file
version of the entire parse tree. 
Of course, the parse code module is clearly
written so it can be debugged if desired. More likely is that
the programmer would set break points only in his action code, 
bypassing all of the code created by the parser generator.

<p>
The SLK parser generator creates LL(k) parsing code modules.
These can be combined with a lexical analyzer and semantic action code
to produce translators or compilers.

Some of the features of the SLK parser generator follow.
<ul>
<li>
SLK implements <B>new lookahead algorithms</B> that are not available
in any other parser generator. One is an efficient
grammar analysis algorithm and
the other is a new table-driven LL(k) parsing algorithm.
The new grammar analysis algorithm can very quickly analyze
most grammars, even for 
<a href="documentation.html#SLK_Performance">
large k-values</a>.
</li>

<br>
<li>
SLK produces parsers that are nearly the
<a href="documentation.html#SLK_Quotations">
fastest and most compact</a> that is possible.
The table compaction algorithms become more and more effective as
the grammar size increases. This relationship is nearly exponential
because the tables become extremely sparse as their size increases.
A side effect of this is that very large grammars can be handled
more easily than is the case with recursive-descent.
There is no need to try to keep the grammar compact,
at the expense of readability. 
</li>

<br>
<li>
SLK produces <B>fully modular parsers</B>.
Actions are invoked by number through a
call table that is a parameter to the parser. The semantic stack
is action-controlled for maximum flexibility. This means that
the semantic stack is fully contained in, and controlled by the
user-written action code.
This approach is also more efficient because attribute assignment
is only done where needed. Problems that sometimes occur because
of the default $$=$1 assignment are avoided.
</li>
                               
<br>
<li>
The SLK parser specification language, the grammar, is
completely programming language independent. The grammar is the
only input to the parser generator, so the same grammar can be
used to produce parsers in all of the supported programming
languages.
</li>
                               
<br>
<li>
SLK currently supports the <B>C, C++, C#, Java and JavaScript</B>
languages on all platforms.
Note that the SLK parsers primarily consist of tables
of integers as arrays and a very small parse routine
that only uses the simple, and universally supported
features of the language. This is in contrast to
parser generators that produce recursive descent code.
They must force a certain programming model on the user
because the parsing code is intermixed with the user 
action code. <B>SLK places no limits or requirements on
the coding style of the user.</B>
</li>

<br>
<li>
SLK introduced a new and more
<a href="documentation.html#SLKsyntax">
precise action placement syntax</a>
for EBNF notation.
An action that is specified just after the end brace/bracket 
is only executed when the EBNF construct goes to null.
An action that is specified just before the end brace/bracket 
is only executed when the EBNF construct does not go to null.
This simplifies the semantic action code, since it does not
need to handle both of these cases in the same action. 
</li>

<br>
<li>
The SLK parsers are reentrant and thread-safe.
The parsers have no library dependencies, so they are well-suited
to <B>embedded applications</B>.
Any number of parsers for different grammars can be
contained in a single program.
Compiling SLK parsers is never a problem.
All C, C++, C#, Java and JavaScript compilers and interpreters are fully supported.
</li>

<br>
<li>
SLK supports a new
<a href="documentation.html#SLKsyntax">
white space delimited syntax</a>
that accepts grammars
in the forms commonly found in published reference grammars.
This syntax eliminates the need for reserved tokens, making
the grammars appear cleaner. More descriptive identifiers
result from the ability to use almost any ASCII character. 
For example, ;_opt and ,_id_* are valid nonterminal symbols in SLK.
Quotes or terminal declarations are not needed for terminal symbols,
so operators like != and -> can be written in the grammar as they are.
This syntax supports both BNF and EBNF notation.
SLK also supports a YACC-style BNF grammar syntax
as a legacy, and to aid in porting a grammar from YACC to SLK. 
</li>

<br>
<li>
SLK includes <B>automated grammar transformation</B> options that
convert reference grammars to top-down format. These include
smart left-factoring and left-recursion elimination. The new
left-factoring algorithm does not convert those constructs
that could be handled by the LL(k) lookahead. SLK
also has extensive grammar debugging capabilities.
</li>

<br>
<li>
Predictive <B>backtracking</B>, also called LL(inf) or PEG,
can be used selectively on the nonterminals that LL(k) is unable to handle.
Predictive backtracking predicts which production to use by trying
to parse each one in turn, and returning the first one that parses 
without error to the mainline parser.
Semantic actions are not executed during backtracking, so the process is
transparent to the programmer.
</li>

<br>
<li>
The SLK parser generator
can also be used to aid in the development of hand-written
<B>recursive descent</B> compilers.
The -Da option can be used to display the parse table in
readable text form. Only the valid entries are included,
making it well suited to translation to recursive descent. 
The conflict table is also displayed as well as the FIRST and FOLLOW
sets.
</li>

<br>
<li>
The SLK conflict resolution capability is now exported for use with
any parser or parsing tool. If a conflict can be resolved by the use
of extra lookahead, SLK will generate code to do this. It should be
noted that for LR grammars many types of conflicts are not 
solvable with extra lookahead.
</li>

<!--
...
</li><li>
Mirror site: <a href="http://slkpg.1eko.com"> http://slkpg.1eko.com</a><br>
</li><li>
Mirror site: <a href="http://slkpg.byethost7.com"> http://slkpg.byethost7.com</a><br>
-->

</ul>

<h3>
Parsing Theory
</h3>

<ul>
<li>
<a href="determin.html">Deterministic Parsing Theory</a><br>
</li><li>
<a href="ll1parse.html">LL(1) Parsing Theory</a><br>
</li><li>
<a href="llkparse.html">LL(k) Parsing Theory</a><br>
</li><li>
<a href="predictk.html">The PREDICT-k Function</a><br>
</li>
</ul>
                                     
<!--
<h3>
Complexity Theory
</h3>
<ul>
<li>
<a href="NPcoNP.html">NP is not equal to coNP</a><br>
</li>
</ul>
-->
                                     
<h3>
Programming
</h3>

<ul>
<li>
<a href="instance.html">Instance Model Programming</a><br>
</li><li>
<a href="cstructs.html">C With Structs</a><br>
</li><li>
<a href="download.html">Command line CD play utility - playcd.c</a><br>
</li><li>
<a href="download.html">Command line disk image utility - drvimage.c</a><br>
</li><li>
<a href="download.html">Android button to set screen brightness to 100% - brite.apk</a><br>
</li>
</ul>
                                     
</FONT>
<hr>
<CENTER>
<FONT FACE="Verdana, Arial, Helvetica" SIZE=1>
<B>               
<a href="index.html">Home</a> |
<a href="documentation.html#SLK_FAQ">FAQ</a> | 
<a href="documentation.html">Docs</a> |
<a href="download.html">Download</a> |
<!-- 
<a href="products.html">Products</a> |
-->
<a href="mailto: SLK Support<mail@h8dems.com>">Support</a> |
<a href="mailto: SLK Inquiry<mail@h8dems.com>">Contact</a>
</B>
<br><br>
Copyright &copy; 2001-2019 SLK Systems
</FONT>
</CENTER>

</body>
</html>
